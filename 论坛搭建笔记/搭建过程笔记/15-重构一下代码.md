# 15-重构一下代码
### 一些在重构中要用到的Laravel特性
1.scope
参考[query scope](https://docs.golaravel.com/docs/5.0/eloquent/#query-scopes)
> 要定义一个可能经常需要获取的作用域，只需简单在对应 Eloquent 模型方法前加上一个 scope 前缀，作用域总是返回查询构建器，一旦定义了范围，则可以在查询模型时调用范围方法。在进行方法调用时不需要加上 scope 前缀。甚至可以链式调用不同的范围。

2.filter
参考[filter](d.laravel-china.org/docs/5.4/collections.html#collection-method)
> 使用回调函数筛选集合，只留下那些通过判断测试的项目,如果没有提供回调函数，集合中所有返回 false 的元素都会被移除.

3.flip
参考[flip](d.laravel-china.org/docs/5.4/collections.html#collection-method)
> 将集合中的键和对应的数值进行互换.

### 正式开始重构
这次重构主要是针对上一篇的ThreadsController的index方法：

```
public function index(Channel $channel)
{
    if($channel->exists){
        $threads = $channel->threads()->latest();
    }else{
        $threads = Thread::latest();
    }
    
    if($username = request('by')){
        $user = \App\User::where('name', $username)->firstOrFail();
        $threads->where('user_id', $user->id);
    }

    $threads = $threads->get();

    return view('threads.index', compact('threads'));
}
```
在它的index方法中做了许多事：判断是否通过筛选channel；是否通过用户筛选；以及列出所有的thread列表。

这并不是一件好事，一个函数应该只有一个任务；另外一件重要的事就是除了根据用户名来筛选，后面还可能根据受欢迎程度或其他东西来筛选，目前的这个状态并不适合扩展它的功能。

#### 第一步重构
1.在index方法使用filter来筛选查询构造器

```
public function index(Channel $channel, ThreadFilters $filters)
{
    if($channel->exists){
        $threads = $channel->threads()->latest();
    }else{
        $threads = Thread::latest();
    }
    
    $threads = $threads->filter($filters)->get();
    
    return view('threads.index', compact('threads'));
}
```

2.在Thread.php中添加scopeFilter

```
public function scopeFilter($query, $filters)
{
    return $filters->apply($query);
}
```
注意：`$query`参数是scope方法自带的

3.新建ThreadFilters

```
class ThreadFilters
{
	public function __construct(Request $request)
	{
		$this->request = $request;
	}

	function apply($builder)
	{
		if(!$username = $this->request->by)
			return $builder;

        $user = User::where('name', $username)->firstOrFail();
        return $builder->where('user_id', $user->id);
	}
}
```
这里要注意的是，对`$threads`的操作不论是`$threads = $channel->threads()->latest();`还是`$threads = Thread::latest();`，返回的均是一个类型为`Illuminate\Database\Query\Builder`也就是查询构造器类。

而如果对$threads变量进行了`get()`操作以后，获得的是一个`Illuminate\Support\Collection`也就是集合类。它们之间是有区别的！

所以`$threads = $threads->filter($filters)->get();`这一条语句是对`$threads`这个**查询构造器**调用filter方法，传递一个`ThreadFilters`参数给filter方法，这个方法并不是我们前面提到的**集合的方法**`filter`！

查询构造器的方法filter，其实就是调用了Thread.php中声明的`scopeFilter`方法，该方法的第一个参数是一个`$query`也就是查询构造器本身，第二个参数是负责调用回调函数的类`filters`，`scopeFilter`方法将`$query`也就是查询构造器本身传递给了`filters`的apply方法。

把`$query`传递之后在apply中把它叫做`$builder`，接下来由apply方法来对`$builder`也就是查询构造器进行进一步筛选，并调用了`$query`也就是`$builder`的`where`方法获得了另一个查询构造器，最终把这个查询构造器返回。

#### 进一步重构
1.把apply函数分解：

```
function apply($builder)
{
	$this->builder = $builder;

	if(!$username = $this->request->by)
		return $builder;

    return $this->by($username);
}

function by($username)
{
	$user = User::where('name', $username)->firstOrFail();
    return $this->builder->where('user_id', $user->id);
}
```
这一部分用到了重构手法——`Move Method`，另外就是把`$builder`放到自己的属性数据之中，避免多次传递它。

2.整理apply函数：

```
function apply($builder)
{
	$this->builder = $builder;

	if($this->request->has('by')){
		$this->by($this->request->by);
	}

    return $this->builder;
}
```
这一步中消除了临时变量`$username`

3.将筛选器提取到抽象类之中：

```
//Filters.php
abstract class Filters
{
	protected $request, $builder;

	public function __construct(Request $request)
	{
		$this->request = $request;
	}

	function apply($builder)
	{
		$this->builder = $builder;

		if($this->request->has('by')){
			$this->by($this->request->by);
		}

        return $this->builder;
	}
}

//ThreadFilters.php
class ThreadFilters extends Filters
{
	function by($username)
	{
		$user = User::where('name', $username)->firstOrFail();
        return $this->builder->where('user_id', $user->id);
	}
}
```
可能以后还会需要其他的筛选器，所以可以把共同的部分提取到一个抽象的超类之中。

4.在这里注意到apply方法用到了`by`变量，这表示只能筛选request中的by变量内容，这并不是我希望的，所以可以利用PHP的[可变变量](http://php.net/manual/zh/language.variables.variable.php)和[method_exists](http://php.net/manual/zh/function.method-exists.php)这些功能来进一步让它完善：

```
//Filter.php
protected $filters = [];

function apply($builder)
{
	$this->builder = $builder;

	foreach($this->filters as $filter){
		if(method_exists($this, $filter) && $this->request->has($filter)){
			$this->$filter($this->request->$filter);
		}
	}

    return $this->builder;
}

//ThreadFilters.php
protected $filters = ['by'];
```
这样以来，apply会自动调用所有的子类的筛选器而不用知道它们叫什么和是什么。

4.简化if语句
if语句中需要判断两个条件：1)该filter方法存在；2)request中包含filter参数，而恰好Laravel提供了一个方便的函数[intersect](d.laravel-china.org/docs/5.4/requests.html#获取部分输入数据)，当想要获取请求中实际存在的输入数据时，可以使用 intersect 方法：

```
function apply($builder)
{
	$this->builder = $builder;

	foreach($this->getFilters() as $filter => $value){
		if(method_exists($this, $filter)){
			$this->$filter($value);
		}
	}

    return $this->builder;
}

function getFilters()
{
	return $this->request->intersect($this->filters);
}
```
这样就可以直接在foreach的起始语句中获得request中含有的值和filters数组中含有的值的交集，从而替代掉if语句中的`$this->request->has($filter)`。

5.继续简化index方法：

```
public function index(Channel $channel, ThreadFilters $filters)
{
    $threads = Thread::latest()->filter($filters);

    if($channel->exists){
        $threads->where('channel_id', $channel->id);
    }

    $threads = $threads->get();

    return view('threads.index', compact('threads'));
}
```

6.最后一步，再次`Move Method`：

```
public function index(Channel $channel, ThreadFilters $filters)
{
    $threads = $this->getThreads($channel, $filters);

    return view('threads.index', compact('threads'));
}

public function getThreads(Channel $channel, ThreadFilters $filters)
{
    $threads = Thread::latest()->filter($filters);

    if($channel->exists){
        $threads->where('channel_id', $channel->id);
    }

    return $threads->get();
}
```


